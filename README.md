# Data Structures & Algorithms (DSA) with Java  

Welcome to the **DSA with Java Series**  

This repository is a **complete learning roadmap** for mastering **Data Structures and Algorithms** using **Java**.  
It covers everything — from the **Mathematics foundations** to **advanced DSA concepts**, with explanations, structured notes, and practice problems.  

---

##  Why Learn DSA?  

- Sharpen **problem-solving skills**  
- Crack **coding interviews (FAANG, Product-based companies)**  
- Build **efficient applications**  
- Improve **logical & analytical thinking**  

---

##  Contents  

This repo is organized **step by step**. Each section contains:  
- Explanations (Markdown notes)  
- Java Code implementations  
- Practice problems  

---

### Roadmap  

<details>
<summary>Mathematics for DSA</summary>

- Number Theory: GCD, LCM, Prime Numbers, Modular Arithmetic  
- Logarithms & Exponents  
- Combinatorics: Factorials, nCr, nPr  
- Probability Basics  
- Bit Manipulation: AND, OR, XOR, Shifts, Subset Generation  
</details>

---

<details>
<summary>Arrays</summary>

- Introduction & Basics  
- 1D & 2D Arrays  
- Searching: Linear, Binary Search  
- Sorting: Bubble, Selection, Insertion, Merge, Quick, Counting, Radix  
- Prefix Sum & Difference Arrays  
- Sliding Window Technique  
- Two Pointers Technique  
- Subarray Problems  
</details>

---

<details>
<summary>Strings</summary>

- String vs StringBuilder  
- Character Arrays vs Strings  
- Palindromes  
- Anagrams & Permutations  
- Pattern Matching: Naive, KMP, Rabin-Karp, Z-Algorithm  
- Longest Common Prefix (LCP)  
- Substrings & Subsequences  
</details>

---

<details>
<summary>Recursion & Backtracking</summary>

- Recursion Fundamentals  
- Tail vs Non-Tail Recursion  
- Factorials, Fibonacci, Power Functions  
- Backtracking Concepts  
- Classic Problems: N-Queens, Sudoku Solver, Rat in a Maze  
- Subset & Subsequence Generation  
</details>

---

<details>
<summary>Linked Lists</summary>

- Singly Linked List  
- Doubly Linked List  
- Circular Linked List  
- Fast & Slow Pointer Technique (Cycle Detection)  
- Merging Two Lists  
- Reversal (Iterative & Recursive)  
- Intersection Problems  
</details>

---

<details>
<summary>Stacks & Queues</summary>

- Stack (Array & Linked List Implementation)  
- Applications of Stack: Balanced Parentheses, Expression Evaluation  
- Queue (Array, Linked List Implementation)  
- Circular Queue  
- Deque (Double Ended Queue)  
- Monotonic Stack (Next Greater Element)  
- Priority Queue  
</details>

---

<details>
<summary>Trees</summary>

- Binary Tree Basics  
- Traversals: Inorder, Preorder, Postorder, Level Order  
- Height & Diameter of Tree  
- Binary Search Tree (BST)  
- Balanced Trees (AVL, Red-Black Trees - overview)  
- Lowest Common Ancestor (LCA)  
- Trie (Prefix Tree)  
- Segment Trees (Intro + Basics)  
</details>

---

<details>
<summary>Graphs</summary>

- Graph Representation: Adjacency List, Adjacency Matrix  
- BFS (Breadth-First Search)  
- DFS (Depth-First Search)  
- Shortest Path Algorithms: Dijkstra, Bellman-Ford, Floyd-Warshall  
- Minimum Spanning Tree: Kruskal, Prim  
- Topological Sort  
- Connected Components  
- Bipartite Graphs  
- Union-Find (Disjoint Set Union)  
</details>

---

<details>
<summary>Dynamic Programming (DP)</summary>

- Introduction: Memoization vs Tabulation  
- Fibonacci & Climbing Stairs  
- Knapsack Variants (0/1, Unbounded, Subset Sum)  
- Longest Increasing Subsequence (LIS)  
- Matrix DP: Minimum Path Sum, Unique Paths  
- DP on Strings: LCS, Edit Distance, Palindrome Partitioning  
- DP on Subsequences  
- DP Optimization Techniques  
</details>

---

<details>
<summary> Advanced Topics</summary>

- Segment Tree (Range Queries, Lazy Propagation)  
- Fenwick Tree (Binary Indexed Tree)  
- Disjoint Set Union (Union-Find with Path Compression)  
- Greedy Algorithms: Activity Selection, Huffman Coding, Interval Scheduling  
- Heaps: Min Heap, Max Heap, Heap Sort, Priority Queue  
- Hashing: HashMap, HashSet, Collision Handling  
</details>

---

## Problem Solving Strategy  

1. Start with basics (Math, Arrays, Strings)  
2. Move step by step to advanced topics  
3. Solve **easy → medium → hard** problems  
4. Focus on **Time & Space Complexity**  
5. Write clean, reusable Java code  

---

## Resources  

- **Followed by**:  
  - [Shaswat Tiwari](https://www.youtube.com/@shashwat_tiwari_st)  

- **Platforms**:  
  - [LeetCode](https://leetcode.com/)  
  - [GeeksforGeeks](https://www.geeksforgeeks.org/)  
  - [Codeforces](https://codeforces.com/)  
  - [HackerRank](https://www.hackerrank.com/)  

*Pro Tip*: Solve **1 problem daily** → 365 problems in a year


